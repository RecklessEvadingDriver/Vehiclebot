#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸš— Professional Vehicle RC Information Bot
A comprehensive Telegram bot for vehicle registration lookup with advanced features

Author: RC Info Bot Team
Version: 3.0.0
License: MIT
"""

import logging
import requests
import json
import time
import sqlite3
import os
import re
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List
from io import BytesIO
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, 
    ContextTypes, CallbackQueryHandler, ConversationHandler
)

# ===== CONFIGURATION =====
BOT_TOKEN = os.getenv("BOT_TOKEN", "YOUR_BOT_TOKEN_HERE")
API_BASE = "https://vvvin-ng.vercel.app/lookup?rc="
ADMIN_IDS = list(map(int, os.getenv("ADMIN_IDS", "").split(","))) if os.getenv("ADMIN_IDS") else []
DATABASE_FILE = "vehicle_intel.db"
MAX_QUERIES_PER_DAY = int(os.getenv("MAX_QUERIES_PER_DAY", "50"))
CACHE_EXPIRY_HOURS = 24

# Enable comprehensive logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Conversation states
WAITING_RC, BATCH_MODE, WAITING_FEEDBACK = range(3)

# RC Number validation pattern
RC_PATTERN = re.compile(r'^[A-Z]{2}\d{1,2}[A-Z]{1,2}\d{1,4}$')

class VehicleIntelBot:
    """Professional Vehicle Intelligence Bot with advanced features"""
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'application/json',
            'Accept-Language': 'en-US,en;q=0.9',
        })
        self.init_database()
        logger.info("âœ… Vehicle Intelligence Bot initialized successfully")

    def init_database(self):
        """Initialize comprehensive SQLite database schema"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        # Users table with detailed tracking
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                username TEXT,
                first_name TEXT,
                last_name TEXT,
                queries_count INTEGER DEFAULT 0,
                queries_today INTEGER DEFAULT 0,
                last_query_date DATE,
                first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                is_premium BOOLEAN DEFAULT 0,
                is_banned BOOLEAN DEFAULT 0
            )
        ''')
        
        # Queries history table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS queries (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                rc_number TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                success BOOLEAN,
                error_message TEXT,
                FOREIGN KEY (user_id) REFERENCES users (user_id)
            )
        ''')
        
        # Cache table for API responses
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS cache (
                rc_number TEXT PRIMARY KEY,
                response_data TEXT,
                cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                hits INTEGER DEFAULT 0
            )
        ''')
        
        # Feedback table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS feedback (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                message TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (user_id)
            )
        ''')
        
        conn.commit()
        conn.close()
        logger.info("ğŸ“Š Database initialized successfully")

    def log_user_activity(self, user_id: int, username: str, first_name: str, last_name: str) -> None:
        """Log user activity with daily quota management"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        # Check if it's a new day for this user
        cursor.execute('SELECT last_query_date FROM users WHERE user_id = ?', (user_id,))
        result = cursor.fetchone()
        
        today = datetime.now().date()
        reset_daily = False
        
        if result:
            last_date = datetime.strptime(result[0], '%Y-%m-%d').date() if result[0] else None
            if last_date != today:
                reset_daily = True
        
        # Update or insert user
        cursor.execute('''
            INSERT INTO users 
            (user_id, username, first_name, last_name, queries_count, queries_today, last_query_date, last_seen)
            VALUES (?, ?, ?, ?, 1, 1, ?, CURRENT_TIMESTAMP)
            ON CONFLICT(user_id) DO UPDATE SET
                username = excluded.username,
                first_name = excluded.first_name,
                last_name = excluded.last_name,
                queries_count = queries_count + 1,
                queries_today = CASE WHEN ? THEN 1 ELSE queries_today + 1 END,
                last_query_date = excluded.last_query_date,
                last_seen = CURRENT_TIMESTAMP
        ''', (user_id, username, first_name, last_name, today, reset_daily))
        
        conn.commit()
        conn.close()

    def check_user_quota(self, user_id: int) -> tuple[bool, int]:
        """Check if user has remaining quota for today"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT queries_today, is_premium, is_banned 
            FROM users WHERE user_id = ?
        ''', (user_id,))
        
        result = cursor.fetchone()
        conn.close()
        
        if not result:
            return True, MAX_QUERIES_PER_DAY
        
        queries_today, is_premium, is_banned = result
        
        if is_banned:
            return False, 0
        
        # Premium users have unlimited queries
        if is_premium:
            return True, -1
        
        remaining = MAX_QUERIES_PER_DAY - queries_today
        return remaining > 0, remaining

    def log_query(self, user_id: int, rc_number: str, success: bool, error_message: str = None) -> None:
        """Log individual query with error tracking"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO queries (user_id, rc_number, success, error_message)
            VALUES (?, ?, ?, ?)
        ''', (user_id, rc_number.upper(), success, error_message))
        
        conn.commit()
        conn.close()

    def cache_response(self, rc_number: str, response_data: Dict[str, Any]) -> None:
        """Cache API response for faster subsequent queries"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO cache (rc_number, response_data, cached_at, hits)
            VALUES (?, ?, CURRENT_TIMESTAMP, 
                COALESCE((SELECT hits FROM cache WHERE rc_number = ?), 0) + 1)
        ''', (rc_number.upper(), json.dumps(response_data), rc_number.upper()))
        
        conn.commit()
        conn.close()

    def get_cached_response(self, rc_number: str) -> Optional[Dict[str, Any]]:
        """Retrieve cached response if available and not expired"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT response_data, cached_at FROM cache 
            WHERE rc_number = ?
        ''', (rc_number.upper(),))
        
        result = cursor.fetchone()
        conn.close()
        
        if not result:
            return None
        
        cached_data, cached_at = result
        cached_time = datetime.strptime(cached_at, '%Y-%m-%d %H:%M:%S')
        
        # Check if cache is still valid
        if datetime.now() - cached_time > timedelta(hours=CACHE_EXPIRY_HOURS):
            return None
        
        return json.loads(cached_data)

    def validate_rc_number(self, rc_number: str) -> bool:
        """Validate RC number format"""
        rc_clean = rc_number.strip().upper().replace(" ", "").replace("-", "")
        return bool(RC_PATTERN.match(rc_clean))

    def get_user_stats(self, user_id: int) -> Dict[str, Any]:
        """Get detailed statistics for a user"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT queries_count, queries_today, first_seen, last_seen, is_premium
            FROM users WHERE user_id = ?
        ''', (user_id,))
        
        result = cursor.fetchone()
        
        if not result:
            conn.close()
            return None
        
        queries_count, queries_today, first_seen, last_seen, is_premium = result
        
        # Get recent queries
        cursor.execute('''
            SELECT rc_number, timestamp, success 
            FROM queries 
            WHERE user_id = ? 
            ORDER BY timestamp DESC 
            LIMIT 5
        ''', (user_id,))
        
        recent_queries = cursor.fetchall()
        conn.close()
        
        return {
            "total_queries": queries_count,
            "queries_today": queries_today,
            "remaining_today": -1 if is_premium else max(0, MAX_QUERIES_PER_DAY - queries_today),
            "first_seen": first_seen,
            "last_seen": last_seen,
            "is_premium": is_premium,
            "recent_queries": recent_queries
        }

    def get_admin_stats(self) -> Dict[str, Any]:
        """Get comprehensive admin statistics"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        # Total users
        cursor.execute('SELECT COUNT(*) FROM users')
        total_users = cursor.fetchone()[0]
        
        # Total queries
        cursor.execute('SELECT COUNT(*) FROM queries')
        total_queries = cursor.fetchone()[0]
        
        # Successful queries
        cursor.execute('SELECT COUNT(*) FROM queries WHERE success = 1')
        successful_queries = cursor.fetchone()[0]
        
        # Queries today
        cursor.execute('''
            SELECT COUNT(*) FROM queries 
            WHERE DATE(timestamp) = DATE('now')
        ''')
        queries_today = cursor.fetchone()[0]
        
        # Active users today
        cursor.execute('''
            SELECT COUNT(DISTINCT user_id) FROM queries 
            WHERE DATE(timestamp) = DATE('now')
        ''')
        active_today = cursor.fetchone()[0]
        
        # Top 5 users
        cursor.execute('''
            SELECT user_id, username, queries_count 
            FROM users 
            ORDER BY queries_count DESC 
            LIMIT 5
        ''')
        top_users = cursor.fetchall()
        
        # Most queried RCs
        cursor.execute('''
            SELECT rc_number, COUNT(*) as count 
            FROM queries 
            GROUP BY rc_number 
            ORDER BY count DESC 
            LIMIT 5
        ''')
        top_rcs = cursor.fetchall()
        
        # Cache stats
        cursor.execute('SELECT COUNT(*) FROM cache')
        cache_size = cursor.fetchone()[0]
        
        conn.close()
        
        return {
            "total_users": total_users,
            "total_queries": total_queries,
            "successful_queries": successful_queries,
            "queries_today": queries_today,
            "active_today": active_today,
            "success_rate": (successful_queries / total_queries * 100) if total_queries > 0 else 0,
            "top_users": top_users,
            "top_rcs": top_rcs,
            "cache_size": cache_size
        }

    def save_feedback(self, user_id: int, message: str) -> None:
        """Save user feedback"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO feedback (user_id, message)
            VALUES (?, ?)
        ''', (user_id, message))
        
        conn.commit()
        conn.close()

    def get_feedback_list(self) -> List[tuple]:
        """Get recent feedback for admins"""
        conn = sqlite3.connect(DATABASE_FILE)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT f.id, f.user_id, u.username, f.message, f.timestamp
            FROM feedback f
            LEFT JOIN users u ON f.user_id = u.user_id
            ORDER BY f.timestamp DESC
            LIMIT 10
        ''')
        
        feedback = cursor.fetchall()
        conn.close()
        
        return feedback

    async def query_rc_api(self, rc_number: str, use_cache: bool = True) -> Dict[str, Any]:
        """Enhanced API query with caching, retry logic and comprehensive error handling"""
        rc_clean = rc_number.strip().upper().replace(" ", "").replace("-", "")
        
        # Validate RC format
        if not self.validate_rc_number(rc_clean):
            return {"error": "Invalid RC number format. Example: MH12DE1433"}
        
        # Check cache first
        if use_cache:
            cached = self.get_cached_response(rc_clean)
            if cached:
                logger.info(f"âœ… Cache hit for {rc_clean}")
                cached['from_cache'] = True
                return cached
        
        # Query API with retry logic
        max_retries = 3
        for attempt in range(max_retries):
            try:
                url = f"{API_BASE}{rc_clean}"
                logger.info(f"ğŸ” Querying API: {url} (Attempt {attempt + 1}/{max_retries})")
                
                response = self.session.get(url, timeout=20)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    # Check if API returned error
                    if isinstance(data, dict) and data.get('error'):
                        return {"error": data.get('error')}
                    
                    # Parse and cache the response
                    parsed_data = self.parse_intel_data(data, rc_clean)
                    if 'error' not in parsed_data:
                        self.cache_response(rc_clean, parsed_data)
                    
                    return parsed_data
                    
                elif response.status_code == 404:
                    return {"error": "âŒ Vehicle not found in database"}
                elif response.status_code == 429:
                    return {"error": "âš ï¸ Rate limit exceeded. Please try again later"}
                else:
                    if attempt < max_retries - 1:
                        time.sleep(2 ** attempt)  # Exponential backoff
                        continue
                    return {"error": f"API Error: HTTP {response.status_code}"}
                    
            except requests.exceptions.Timeout:
                if attempt < max_retries - 1:
                    logger.warning(f"â±ï¸ Timeout on attempt {attempt + 1}, retrying...")
                    time.sleep(2 ** attempt)
                    continue
                return {"error": "â±ï¸ Request timeout - API is unresponsive"}
                
            except requests.exceptions.ConnectionError:
                if attempt < max_retries - 1:
                    time.sleep(2 ** attempt)
                    continue
                return {"error": "ğŸŒ Connection error - Please check your internet"}
                
            except Exception as e:
                logger.error(f"âŒ Unexpected error: {str(e)}")
                return {"error": f"System error: {str(e)}"}
        
        return {"error": "Failed to fetch data after multiple attempts"}

    def parse_intel_data(self, data: Any, rc_number: str) -> Dict[str, Any]:
        """Parse and structure comprehensive intelligence data from API"""
        if not isinstance(data, dict):
            return {"error": "Invalid API response format"}
        
        # Create comprehensive intelligence report with all API fields
        intel_report = {
            "metadata": {
                "target": rc_number,
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "data_confidence": "HIGH",
                "from_cache": False
            },
            
            # ğŸš— Ownership Details
            "ownership": {
                "ğŸ˜€ Owner Name": data.get("Owner Name", "N/A"),
                "ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ Father's Name": data.get("Father's Name", "N/A"),
                "ğŸ”¢ Owner Serial No": data.get("Owner Serial No", "N/A"),
                "ğŸªª Registration Number": data.get("Registration Number", rc_number)
            },
            
            # ğŸ¢ Registered RTO
            "rto": {
                "ğŸ¢ Registered RTO": data.get("Registered RTO", "N/A")
            },
            
            # ğŸ§° Vehicle Details
            "vehicle": {
                "ğŸš˜ Model Name": data.get("Model Name", "N/A"),
                "ğŸ­ Maker Model": data.get("Maker Model", "N/A"),
                "ğŸ’ Vehicle Class": data.get("Vehicle Class", "N/A"),
                "ğŸ§¤ Fuel Type": data.get("Fuel Type", "N/A"),
                "â˜ƒï¸ Fuel Norms": data.get("Fuel Norms", "N/A"),
                "ğŸ”© Chassis Number": data.get("Chassis Number", "N/A"),
                "ğŸ§  Engine Number": data.get("Engine Number", "N/A"),
                "âš™ï¸ Cubic Capacity": data.get("Cubic Capacity", "N/A"),
                "ğŸ‘¥ Seating Capacity": data.get("Seating Capacity", "N/A")
            },
            
            # ğŸ“„ Insurance Information
            "insurance": {
                "ğŸ§ Insurance Expiry": data.get("Insurance Expiry", "N/A"),
                "ğŸ”– Insurance No": data.get("Insurance No", "N/A"),
                "ğŸ¢ Insurance Company": data.get("Insurance Company", "N/A"),
                "ğŸ¶ Insurance Upto": data.get("Insurance Upto", "N/A"),
                "ğŸš« Insurance Expiry In": data.get("Insurance Expiry In", "N/A"),
                "â± Insurance Alert": data.get("Insurance Alert", "N/A"),
                "ğŸ—“ï¸ Expired Days": data.get("Expired Days", "N/A")
            },
            
            # ğŸ—“ Important Dates & Validity
            "dates": {
                "ğŸ‘‘ Registration Date": data.get("Registration Date", "N/A"),
                "â³ Vehicle Age": data.get("Vehicle Age", "N/A"),
                "ğŸ§¾ Fitness Upto": data.get("Fitness Upto", "N/A"),
                "ğŸ˜€ Tax Upto": data.get("Tax Upto", "N/A"),
                "ğŸ§§ PUC No": data.get("PUC No", "N/A"),
                "ğŸ—“ï¸ PUC Upto": data.get("PUC Upto", "N/A"),
                "âš¡ï¸ PUC Expiry In": data.get("PUC Expiry In", "N/A")
            },
            
            # ğŸ› Other Information
            "other": {
                "ğŸ˜€ Financer Name": data.get("Financer Name", "N/A"),
                "ğŸªª Permit Type": data.get("Permit Type", "N/A"),
                "ğŸš« Blacklist Status": data.get("Blacklist Status", "N/A")
            },
            
            # ğŸ“ NOC Details
            "noc": {
                "NOC Details": data.get("NOC Details", "N/A")
            },
            
            # ğŸªª Basic Card Info
            "card_info": {
                "ğŸš— Modal Name": data.get("Modal Name", "N/A"),
                "ğŸ˜€ Owner Name": data.get("Owner Name", "N/A"),
                "ğŸ›¡ Code": data.get("Code", "N/A"),
                "ğŸ“ City Name": data.get("City Name", "N/A"),
                "ğŸ›© Phone": data.get("Phone", "N/A"),
                "ğŸŒ Website": data.get("Website", "N/A"),
                "ğŸ˜€ Address": data.get("Address", "N/A")
            },
            
            # Raw data for reference
            "raw_data": data
        }
        
        return intel_report

    def format_intel_message(self, report: Dict[str, Any]) -> str:
        """Format comprehensive intelligence report for Telegram with all fields"""
        if "error" in report:
            return f"âŒ *QUERY FAILED*\n\n{report['error']}\n\nğŸ’¡ _Tip: Make sure the RC number is correct_"
        
        meta = report["metadata"]
        from_cache = " (Cached)" if meta.get("from_cache") else ""
        
        message = "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"
        message += "â•‘  ğŸš— *RC INFORMATION REPORT*  â•‘\n"
        message += "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"
        
        # Metadata
        message += f"ğŸ¯ *Target:* `{meta['target']}`{from_cache}\n"
        message += f"ğŸ• *Generated:* {meta['timestamp']}\n"
        message += f"ğŸ“Š *Confidence:* {meta['data_confidence']}\n"
        message += "â•" * 35 + "\n\n"
        
        # ğŸš— Ownership Details
        message += "ğŸš— *OWNERSHIP DETAILS*\n"
        message += "â”€" * 35 + "\n"
        for key, value in report["ownership"].items():
            if value and value != "N/A":
                message += f"{key}: `{value}`\n"
        
        # ğŸ¢ RTO Information
        if report["rto"].get("ğŸ¢ Registered RTO", "N/A") != "N/A":
            message += "\nğŸ¢ *RTO INFORMATION*\n"
            message += "â”€" * 35 + "\n"
            for key, value in report["rto"].items():
                if value and value != "N/A":
                    message += f"{key}: `{value}`\n"
        
        # ğŸ§° Vehicle Details
        message += "\nğŸ§° *VEHICLE DETAILS*\n"
        message += "â”€" * 35 + "\n"
        for key, value in report["vehicle"].items():
            if value and value != "N/A":
                message += f"{key}: `{value}`\n"
        
        # ğŸ“„ Insurance Information
        message += "\nğŸ“„ *INSURANCE INFORMATION*\n"
        message += "â”€" * 35 + "\n"
        has_insurance_data = False
        for key, value in report["insurance"].items():
            if value and value != "N/A":
                has_insurance_data = True
                message += f"{key}: `{value}`\n"
        
        if not has_insurance_data:
            message += "âš ï¸ _No insurance information available_\n"
        
        # Check for expired insurance warning
        insurance_expiry = report["insurance"].get("ğŸš« Insurance Expiry In", "N/A")
        if "expired" in str(insurance_expiry).lower() or "overdue" in str(insurance_expiry).lower():
            message += "\nâš ï¸ *WARNING:* Insurance has expired! Renew immediately.\n"
        
        # ğŸ—“ Important Dates & Validity
        message += "\nğŸ—“ *IMPORTANT DATES & VALIDITY*\n"
        message += "â”€" * 35 + "\n"
        for key, value in report["dates"].items():
            if value and value != "N/A":
                message += f"{key}: `{value}`\n"
        
        # ğŸ› Other Information
        message += "\nğŸ› *OTHER INFORMATION*\n"
        message += "â”€" * 35 + "\n"
        has_other_data = False
        for key, value in report["other"].items():
            if value and value != "N/A":
                has_other_data = True
                message += f"{key}: `{value}`\n"
        
        if not has_other_data:
            message += "_No additional information_\n"
        
        # ğŸ“ NOC Details
        noc_details = report["noc"].get("NOC Details", "N/A")
        if noc_details and noc_details != "N/A":
            message += "\nğŸ“ *NOC DETAILS*\n"
            message += "â”€" * 35 + "\n"
            message += f"NOC Details: `{noc_details}`\n"
        
        # ğŸªª Basic Card Info (if different from main data)
        message += "\nğŸªª *BASIC CARD INFO*\n"
        message += "â”€" * 35 + "\n"
        has_card_data = False
        for key, value in report["card_info"].items():
            if value and value != "N/A" and key not in ["ğŸ˜€ Owner Name"]:
                has_card_data = True
                message += f"{key}: `{value}`\n"
        
        if not has_card_data:
            message += "_No additional card information_\n"
        
        # ğŸš¨ Security Alerts (Blacklist status)
        blacklist = report["other"].get("ğŸš« Blacklist Status", "N/A")
        if blacklist and blacklist != "N/A" and blacklist.lower() != "no":
            message += "\nğŸš¨ *SECURITY ALERT*\n"
            message += "â”€" * 35 + "\n"
            message += f"âš ï¸ *Blacklist Status:* `{blacklist}`\n"
        
        message += "\n" + "â•" * 35 + "\n"
        message += "ğŸš€ *Made by RC Info Bot*\n"
        message += "ğŸ“± _Powered by VVVin API_\n"
        
        return message

# ===== TELEGRAM BOT HANDLERS =====
bot_instance = VehicleIntelBot()

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for /start command"""
    user = update.effective_user
    bot_instance.log_user_activity(user.id, user.username, user.first_name, user.last_name)
    
    welcome_text = """
ğŸ¤– *VEHICLE INTELLIGENCE BOT v2.0*

*Capabilities:*
â€¢ ğŸ” Vehicle registration lookup
â€¢ ğŸ‘¤ Owner identity verification  
â€¢ âš–ï¸ Legal status monitoring
â€¢ ğŸš¨ Security alert system
â€¢ ğŸ“Š Batch processing mode

*Commands:*
/start - Show this message
/lookup - Single vehicle query  
/batch - Multiple vehicle processing
/stats - Your usage statistics
/admin - Administrator panel

*Usage:* Send /lookup or click button below.
"""
    
    keyboard = [
        [InlineKeyboardButton("ğŸ” Single Lookup", callback_data="single_lookup")],
        [InlineKeyboardButton("ğŸ“Š Batch Mode", callback_data="batch_mode")],
        [InlineKeyboardButton("ğŸ“ˆ My Stats", callback_data="user_stats")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        welcome_text, 
        parse_mode='Markdown',
        reply_markup=reply_markup
    )

async def lookup_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for /lookup command"""
    await update.message.reply_text(
        "ğŸ¯ *SINGLE TARGET MODE*\n\n"
        "Send me the vehicle RC number (e.g., MH12DE1433)\n"
        "I'll gather full intelligence within 15 seconds.",
        parse_mode='Markdown'
    )
    return WAITING_RC

async def handle_rc_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle RC number input"""
    rc_number = update.message.text.strip().upper()
    user_id = update.effective_user.id
    
    # Basic validation
    if len(rc_number) < 5:
        await update.message.reply_text("âŒ Invalid RC number format")
        return WAITING_RC
    
    # Send processing message
    processing_msg = await update.message.reply_text(
        f"ğŸ” *Querying Intelligence Database...*\n"
        f"Target: `{rc_number}`\n"
        f"Please wait â³",
        parse_mode='Markdown'
    )
    
    # Query API
    intel_report = await bot_instance.query_rc_api(rc_number)
    
    # Log the query
    success = "error" not in intel_report
    bot_instance.log_query(user_id, rc_number, success)
    
    # Format and send response
    response_text = bot_instance.format_intel_message(intel_report)
    
    # Edit original message with results
    await processing_msg.edit_text(
        response_text,
        parse_mode='Markdown'
    )
    
    return ConversationHandler.END

async def batch_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler for /batch command"""
    await update.message.reply_text(
        "ğŸ“Š *BATCH PROCESSING MODE*\n\n"
        "Send me RC numbers separated by commas or new lines.\n"
        "Example:\n"
        "MH12DE1433, DL9CAB1234, KA01AB1234",
        parse_mode='Markdown'
    )
    return BATCH_MODE

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle inline keyboard buttons"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "single_lookup":
        await query.edit_message_text(
            "ğŸ¯ *SINGLE TARGET MODE*\n\nSend me the RC number:",
            parse_mode='Markdown'
        )
        return WAITING_RC
    
    elif query.data == "batch_mode":
        await query.edit_message_text(
            "ğŸ“Š *BATCH PROCESSING MODE*\n\nSend multiple RC numbers:",
            parse_mode='Markdown'
        )
        return BATCH_MODE

async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancel conversation"""
    await update.message.reply_text("Operation cancelled.")
    return ConversationHandler.END

def main():
    """Start the bot"""
    # Create Application
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Conversation handler for main flow
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("lookup", lookup_command),
            CommandHandler("batch", batch_command),
            CallbackQueryHandler(button_handler)
        ],
        states={
            WAITING_RC: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_rc_input)],
            BATCH_MODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_rc_input)]
        },
        fallbacks=[CommandHandler("cancel", cancel_command)]
    )
    
    # Add handlers
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(conv_handler)
    
    # Start bot
    print("ğŸ¤– Vehicle Intelligence Bot is running...")
    application.run_polling()

if __name__ == "__main__":
    main()
